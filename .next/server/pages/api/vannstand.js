"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/vannstand";
exports.ids = ["pages/api/vannstand"];
exports.modules = {

/***/ "(api)/./pages/api/vannstand.js":
/*!********************************!*\
  !*** ./pages/api/vannstand.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\nconst NVE_API_KEY = process.env.NVE_API_KEY;\nconst _base = \"https://hydapi.nve.no\";\nconst _path = \"/api/v1/Observations?\";\nconst _stationId = \"2.101.0\";\nconst _parameter = \"1000\";\nconst _resolutionTime = \"hour\";\nconst OFFSETHOURS = -2;\nconst DAYSPAN = 7;\nconst MINDAYSPAN = 1;\nconst MAXDAYSPAN = 15;\nconst MINFULLYEAR = 2017;\nconst MAXFULLYEAR = new Date().getFullYear() + 1;\nconst TODAYDATE = new Date(new Date(new Date(new Date().setHours(0)).setMinutes(0)).setSeconds(0));\nconst validateInputDate = (dateParam)=>{\n    const dateObject = new Date(parseInt(dateParam));\n    if (dateObject.getTime()) {\n        if (dateObject.getFullYear() > MINFULLYEAR && dateObject.getFullYear() < MAXFULLYEAR) {\n            return true;\n        }\n    }\n    return false;\n};\nconst validateDayCount = (daycountParam)=>{\n    if (parseInt(daycountParam) >= MINDAYSPAN && parseInt(daycountParam) <= MAXDAYSPAN) {\n        return true;\n    }\n    return false;\n};\nconst validateParams = async (req)=>{\n    let fromDate, toDate, dayCount;\n    if (req.query.fromdate && validateInputDate(req.query.fromdate)) {\n        fromDate = new Date(parseInt(req.query.fromdate));\n        fromDate = formatDate(fromDate);\n    }\n    if (req.query.todate && validateInputDate(req.query.todate)) {\n        toDate = new Date(parseInt(req.query.todate));\n        toDate = formatDate(toDate, OFFSETHOURS - 1);\n    }\n    if (req.query.daycount && validateDayCount(req.query.daycount)) {\n        dayCount = parseInt(req.query.daycount);\n    }\n    return {\n        fromDate,\n        toDate,\n        dayCount\n    };\n};\nconst formatDate = (date, offset = OFFSETHOURS)=>{\n    let dateObject = new Date(date);\n    // offset for zulu time\n    dateObject = new Date(dateObject.setHours(offset));\n    const year = dateObject.getFullYear();\n    let month = dateObject.getMonth() + 1;\n    month = month < 10 ? \"0\" + month : month;\n    let day = dateObject.getDate();\n    day = day < 10 ? \"0\" + day : day;\n    let hour = dateObject.getHours();\n    hour = hour < 10 ? \"0\" + hour : hour;\n    // return `${year}-${month}-${day}T${hour}:00`;\n    return `${year}-${month}-${day}T${hour}:00`;\n};\nconst formatReferenceTime = ({ fromDate , toDate , dayCount  })=>{\n    /**\r\n     *  Valid parameter combinations\r\n     *\r\n     *  - fromDate && toDate && dayCount | use fromDate and toDate\r\n     *  - fromDate && toDate\r\n     *  - fromDate && dayCount\r\n     *  - toDate && dayCount\r\n     *  - dayCount | use Now() for toDate\r\n     *  - fromDate OR toDate - use $DAYSPAN\r\n     *  - no params | use Now() for toDate and $DAYSPAN for dayCount\r\n     *\r\n     *  */ if (fromDate && toDate) {\n        return `${fromDate}/${toDate}`;\n    }\n    if (fromDate && dayCount) {\n        return `${fromDate}/P${dayCount}D`;\n    }\n    if (toDate && dayCount) {\n        return `P${dayCount}D/${toDate}`;\n    }\n    if (dayCount) {\n        let today = formatDate(TODAYDATE, OFFSETHOURS);\n        return `P${dayCount}D/${today}`;\n    }\n    if (fromDate) {\n        return `P${DAYSPAN}D/${fromDate}`;\n    }\n    if (toDate) {\n        return `${fromDate}/P${DAYSPAN}D`;\n    }\n    let today1 = formatDate(TODAYDATE, OFFSETHOURS);\n    return `P${DAYSPAN}D/${today1}`;\n};\nasync function getData(url = \"\", data = {}) {\n    const response = await fetch(url, {\n        method: \"GET\",\n        mode: \"no-cors\",\n        // cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n        // credentials: \"same-origin\", // include, *same-origin, omit\n        headers: {\n            \"Content-Type\": \"text/plain;charset=UTF-8\",\n            \"x-api-key\": NVE_API_KEY\n        }\n    });\n    const measures = await response.json(); // parses JSON response into native JavaScript objects\n    return measures;\n}\nasync function handler(req, res) {\n    const reqParams = await validateParams(req);\n    const referenceTime = formatReferenceTime(reqParams);\n    const EndPoint = `${_base}${_path}StationId=${_stationId}&Parameter=${_parameter}&ResolutionTime=${_resolutionTime}&ReferenceTime=${referenceTime}`;\n    const vannstandData = await getData(EndPoint, {}).then((data)=>{\n        return data;\n    });\n    res.status(200).send({\n        vannstandData\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQzlDLE9BQU9kLElBQUksQ0FBQztLQUNmLENBQUM7SUFFRlMsR0FBRztRQUFvQkksYUFBYTtLQUFFLENBQUMsQ0FBQztDQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Zhbm5zdGFuZC1hcGkvLi9wYWdlcy9hcGkvdmFubnN0YW5kLmpzPzY5MGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTmV4dC5qcyBBUEkgcm91dGUgc3VwcG9ydDogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJvdXRlcy9pbnRyb2R1Y3Rpb25cclxuY29uc3QgTlZFX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5OVkVfQVBJX0tFWTtcclxuXHJcbmNvbnN0IF9iYXNlID0gXCJodHRwczovL2h5ZGFwaS5udmUubm9cIjtcclxuY29uc3QgX3BhdGggPSBcIi9hcGkvdjEvT2JzZXJ2YXRpb25zP1wiO1xyXG5jb25zdCBfc3RhdGlvbklkID0gXCIyLjEwMS4wXCI7XHJcbmNvbnN0IF9wYXJhbWV0ZXIgPSBcIjEwMDBcIjtcclxuY29uc3QgX3Jlc29sdXRpb25UaW1lID0gXCJob3VyXCI7XHJcblxyXG5jb25zdCBPRkZTRVRIT1VSUyA9IC0yO1xyXG5jb25zdCBEQVlTUEFOID0gNztcclxuY29uc3QgTUlOREFZU1BBTiA9IDE7XHJcbmNvbnN0IE1BWERBWVNQQU4gPSAxNTtcclxuY29uc3QgTUlORlVMTFlFQVIgPSAyMDE3O1xyXG5jb25zdCBNQVhGVUxMWUVBUiA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSArIDE7XHJcblxyXG5jb25zdCBUT0RBWURBVEUgPSBuZXcgRGF0ZShcclxuICAgIG5ldyBEYXRlKG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCkpLnNldE1pbnV0ZXMoMCkpLnNldFNlY29uZHMoMClcclxuKTtcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXREYXRlID0gKGRhdGVQYXJhbSkgPT4ge1xyXG4gICAgY29uc3QgZGF0ZU9iamVjdCA9IG5ldyBEYXRlKHBhcnNlSW50KGRhdGVQYXJhbSkpO1xyXG4gICAgaWYgKGRhdGVPYmplY3QuZ2V0VGltZSgpKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBkYXRlT2JqZWN0LmdldEZ1bGxZZWFyKCkgPiBNSU5GVUxMWUVBUiAmJlxyXG4gICAgICAgICAgICBkYXRlT2JqZWN0LmdldEZ1bGxZZWFyKCkgPCBNQVhGVUxMWUVBUlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5jb25zdCB2YWxpZGF0ZURheUNvdW50ID0gKGRheWNvdW50UGFyYW0pID0+IHtcclxuICAgIGlmIChcclxuICAgICAgICBwYXJzZUludChkYXljb3VudFBhcmFtKSA+PSBNSU5EQVlTUEFOICYmXHJcbiAgICAgICAgcGFyc2VJbnQoZGF5Y291bnRQYXJhbSkgPD0gTUFYREFZU1BBTlxyXG4gICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5jb25zdCB2YWxpZGF0ZVBhcmFtcyA9IGFzeW5jIChyZXEpID0+IHtcclxuICAgIGxldCBmcm9tRGF0ZSwgdG9EYXRlLCBkYXlDb3VudDtcclxuXHJcbiAgICBpZiAocmVxLnF1ZXJ5LmZyb21kYXRlICYmIHZhbGlkYXRlSW5wdXREYXRlKHJlcS5xdWVyeS5mcm9tZGF0ZSkpIHtcclxuICAgICAgICBmcm9tRGF0ZSA9IG5ldyBEYXRlKHBhcnNlSW50KHJlcS5xdWVyeS5mcm9tZGF0ZSkpO1xyXG4gICAgICAgIGZyb21EYXRlID0gZm9ybWF0RGF0ZShmcm9tRGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcS5xdWVyeS50b2RhdGUgJiYgdmFsaWRhdGVJbnB1dERhdGUocmVxLnF1ZXJ5LnRvZGF0ZSkpIHtcclxuICAgICAgICB0b0RhdGUgPSBuZXcgRGF0ZShwYXJzZUludChyZXEucXVlcnkudG9kYXRlKSk7XHJcbiAgICAgICAgdG9EYXRlID0gZm9ybWF0RGF0ZSh0b0RhdGUsIE9GRlNFVEhPVVJTIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcS5xdWVyeS5kYXljb3VudCAmJiB2YWxpZGF0ZURheUNvdW50KHJlcS5xdWVyeS5kYXljb3VudCkpIHtcclxuICAgICAgICBkYXlDb3VudCA9IHBhcnNlSW50KHJlcS5xdWVyeS5kYXljb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tRGF0ZSxcclxuICAgICAgICB0b0RhdGUsXHJcbiAgICAgICAgZGF5Q291bnQsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlLCBvZmZzZXQgPSBPRkZTRVRIT1VSUykgPT4ge1xyXG4gICAgbGV0IGRhdGVPYmplY3QgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgIC8vIG9mZnNldCBmb3IgenVsdSB0aW1lXHJcbiAgICBkYXRlT2JqZWN0ID0gbmV3IERhdGUoZGF0ZU9iamVjdC5zZXRIb3VycyhvZmZzZXQpKTtcclxuXHJcbiAgICBjb25zdCB5ZWFyID0gZGF0ZU9iamVjdC5nZXRGdWxsWWVhcigpO1xyXG5cclxuICAgIGxldCBtb250aCA9IGRhdGVPYmplY3QuZ2V0TW9udGgoKSArIDE7XHJcbiAgICBtb250aCA9IG1vbnRoIDwgMTAgPyBcIjBcIiArIG1vbnRoIDogbW9udGg7XHJcblxyXG4gICAgbGV0IGRheSA9IGRhdGVPYmplY3QuZ2V0RGF0ZSgpO1xyXG4gICAgZGF5ID0gZGF5IDwgMTAgPyBcIjBcIiArIGRheSA6IGRheTtcclxuXHJcbiAgICBsZXQgaG91ciA9IGRhdGVPYmplY3QuZ2V0SG91cnMoKTtcclxuICAgIGhvdXIgPSBob3VyIDwgMTAgPyBcIjBcIiArIGhvdXIgOiBob3VyO1xyXG5cclxuICAgIC8vIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfTowMGA7XHJcblxyXG4gICAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OjAwYDtcclxufTtcclxuXHJcbmNvbnN0IGZvcm1hdFJlZmVyZW5jZVRpbWUgPSAoeyBmcm9tRGF0ZSwgdG9EYXRlLCBkYXlDb3VudCB9KSA9PiB7XHJcbiAgICAvKipcclxuICAgICAqICBWYWxpZCBwYXJhbWV0ZXIgY29tYmluYXRpb25zXHJcbiAgICAgKlxyXG4gICAgICogIC0gZnJvbURhdGUgJiYgdG9EYXRlICYmIGRheUNvdW50IHwgdXNlIGZyb21EYXRlIGFuZCB0b0RhdGVcclxuICAgICAqICAtIGZyb21EYXRlICYmIHRvRGF0ZVxyXG4gICAgICogIC0gZnJvbURhdGUgJiYgZGF5Q291bnRcclxuICAgICAqICAtIHRvRGF0ZSAmJiBkYXlDb3VudFxyXG4gICAgICogIC0gZGF5Q291bnQgfCB1c2UgTm93KCkgZm9yIHRvRGF0ZVxyXG4gICAgICogIC0gZnJvbURhdGUgT1IgdG9EYXRlIC0gdXNlICREQVlTUEFOXHJcbiAgICAgKiAgLSBubyBwYXJhbXMgfCB1c2UgTm93KCkgZm9yIHRvRGF0ZSBhbmQgJERBWVNQQU4gZm9yIGRheUNvdW50XHJcbiAgICAgKlxyXG4gICAgICogICovXHJcblxyXG4gICAgaWYgKGZyb21EYXRlICYmIHRvRGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBgJHtmcm9tRGF0ZX0vJHt0b0RhdGV9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJvbURhdGUgJiYgZGF5Q291bnQpIHtcclxuICAgICAgICByZXR1cm4gYCR7ZnJvbURhdGV9L1Ake2RheUNvdW50fURgO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0b0RhdGUgJiYgZGF5Q291bnQpIHtcclxuICAgICAgICByZXR1cm4gYFAke2RheUNvdW50fUQvJHt0b0RhdGV9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF5Q291bnQpIHtcclxuICAgICAgICBsZXQgdG9kYXkgPSBmb3JtYXREYXRlKFRPREFZREFURSwgT0ZGU0VUSE9VUlMpO1xyXG4gICAgICAgIHJldHVybiBgUCR7ZGF5Q291bnR9RC8ke3RvZGF5fWA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyb21EYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGBQJHtEQVlTUEFOfUQvJHtmcm9tRGF0ZX1gO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0b0RhdGUpIHtcclxuICAgICAgICByZXR1cm4gYCR7ZnJvbURhdGV9L1Ake0RBWVNQQU59RGA7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRvZGF5ID0gZm9ybWF0RGF0ZShUT0RBWURBVEUsIE9GRlNFVEhPVVJTKTtcclxuICAgIHJldHVybiBgUCR7REFZU1BBTn1ELyR7dG9kYXl9YDtcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEodXJsID0gXCJcIiwgZGF0YSA9IHt9KSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIiwgLy8gKkdFVCwgUE9TVCwgUFVULCBERUxFVEUsIGV0Yy5cclxuICAgICAgICBtb2RlOiBcIm5vLWNvcnNcIiwgLy8gbm8tY29ycywgKmNvcnMsIHNhbWUtb3JpZ2luXHJcbiAgICAgICAgLy8gY2FjaGU6IFwibm8tY2FjaGVcIiwgLy8gKmRlZmF1bHQsIG5vLWNhY2hlLCByZWxvYWQsIGZvcmNlLWNhY2hlLCBvbmx5LWlmLWNhY2hlZFxyXG4gICAgICAgIC8vIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsIC8vIGluY2x1ZGUsICpzYW1lLW9yaWdpbiwgb21pdFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcclxuICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogTlZFX0FQSV9LRVksXHJcbiAgICAgICAgICAgIC8vIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgICAgIC8vIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIHJlZGlyZWN0OiBcImZvbGxvd1wiLCAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXHJcbiAgICAgICAgLy8gcmVmZXJyZXJQb2xpY3k6IFwibm8tcmVmZXJyZXJcIiwgLy8gbm8tcmVmZXJyZXIsICpuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSwgb3JpZ2luLCBvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4sIHNhbWUtb3JpZ2luLCBzdHJpY3Qtb3JpZ2luLCBzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luLCB1bnNhZmUtdXJsXHJcbiAgICAgICAgLy8gYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksIC8vIGJvZHkgZGF0YSB0eXBlIG11c3QgbWF0Y2ggXCJDb250ZW50LVR5cGVcIiBoZWFkZXJcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1lYXN1cmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOyAvLyBwYXJzZXMgSlNPTiByZXNwb25zZSBpbnRvIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdHNcclxuICAgIHJldHVybiBtZWFzdXJlcztcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xyXG4gICAgY29uc3QgcmVxUGFyYW1zID0gYXdhaXQgdmFsaWRhdGVQYXJhbXMocmVxKTtcclxuXHJcbiAgICBjb25zdCByZWZlcmVuY2VUaW1lID0gZm9ybWF0UmVmZXJlbmNlVGltZShyZXFQYXJhbXMpO1xyXG5cclxuICAgIGNvbnN0IEVuZFBvaW50ID0gYCR7X2Jhc2V9JHtfcGF0aH1TdGF0aW9uSWQ9JHtfc3RhdGlvbklkfSZQYXJhbWV0ZXI9JHtfcGFyYW1ldGVyfSZSZXNvbHV0aW9uVGltZT0ke19yZXNvbHV0aW9uVGltZX0mUmVmZXJlbmNlVGltZT0ke3JlZmVyZW5jZVRpbWV9YDtcclxuXHJcbiAgICBjb25zdCB2YW5uc3RhbmREYXRhID0gYXdhaXQgZ2V0RGF0YShFbmRQb2ludCwge30pLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKHsgdmFubnN0YW5kRGF0YSB9KTtcclxufVxyXG4iXSwibmFtZXMiOlsiTlZFX0FQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiX2Jhc2UiLCJfcGF0aCIsIl9zdGF0aW9uSWQiLCJfcGFyYW1ldGVyIiwiX3Jlc29sdXRpb25UaW1lIiwiT0ZGU0VUSE9VUlMiLCJEQVlTUEFOIiwiTUlOREFZU1BBTiIsIk1BWERBWVNQQU4iLCJNSU5GVUxMWUVBUiIsIk1BWEZVTExZRUFSIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiVE9EQVlEQVRFIiwic2V0SG91cnMiLCJzZXRNaW51dGVzIiwic2V0U2Vjb25kcyIsInZhbGlkYXRlSW5wdXREYXRlIiwiZGF0ZVBhcmFtIiwiZGF0ZU9iamVjdCIsInBhcnNlSW50IiwiZ2V0VGltZSIsInZhbGlkYXRlRGF5Q291bnQiLCJkYXljb3VudFBhcmFtIiwidmFsaWRhdGVQYXJhbXMiLCJyZXEiLCJmcm9tRGF0ZSIsInRvRGF0ZSIsImRheUNvdW50IiwicXVlcnkiLCJmcm9tZGF0ZSIsImZvcm1hdERhdGUiLCJ0b2RhdGUiLCJkYXljb3VudCIsImRhdGUiLCJvZmZzZXQiLCJ5ZWFyIiwibW9udGgiLCJnZXRNb250aCIsImRheSIsImdldERhdGUiLCJob3VyIiwiZ2V0SG91cnMiLCJmb3JtYXRSZWZlcmVuY2VUaW1lIiwidG9kYXkiLCJnZXREYXRhIiwidXJsIiwiZGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJtb2RlIiwiaGVhZGVycyIsIm1lYXN1cmVzIiwianNvbiIsImhhbmRsZXIiLCJyZXMiLCJyZXFQYXJhbXMiLCJyZWZlcmVuY2VUaW1lIiwiRW5kUG9pbnQiLCJ2YW5uc3RhbmREYXRhIiwidGhlbiIsInN0YXR1cyIsInNlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/vannstand.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/vannstand.js"));
module.exports = __webpack_exports__;

})();